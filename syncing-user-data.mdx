---
title: "Syncing User Data"
description: "How to use Clerk Polling to migrate your users"
---

## Overview

You can use **Clerk Migration Pollers** and **Cursor Pagination** to sync your user data to clerk.

If you start the cursor at the timestamp of your very first user and paginate through all your created users, eventually we will have paginated to the end of your user list.

This extends to updates. If we start the cursor at your first user update, and paginate through all the updates, we will have paginated to the end of the user-updates.

This will continue to happen for all future creations/updates until you turn off your pollers.

## Prerequisite: `created_at` and `updated_at` columns.

In order to poll for new and updated users, your database must have a timestamp tracking when your user data is created and updated.

**The specific name doesn't matter** whether you use `created_at/updated_at` or `createdAt/updatedAt` it doesn't matter as long as the data exists.

### This is required **for all tables that contain user data**. 

For example, if you have a table called `users` and a table called `user_first_names`, which contain the first names of the users. They **both** need the `created_at` and `updated_at` columns if you want Clerk to poll for the changes.

<Tip>
If you are using Supabase or Auth0, your user data already has these columns. However, if you split your user data into multiple tables, this requirment still applies.
</Tip>

### Creating indexes.

Clerk Polling will be searching through your user data using `created_at` and `updated_at` so it is recommended to create indexes on those attributes.

### Here are example sql scripts for common databases:

<AccordionGroup>
  <Accordion title="MySQL">

```sql

-- Adding created_at and updated_at columns to a users table
ALTER TABLE users
ADD COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;

-- Creating an index for the created_at and updated_at columns
CREATE INDEX idx_users_created_at ON users (created_at);
CREATE INDEX idx_users_updated_at ON users (updated_at);
```
  </Accordion>

  <Accordion title="PostgreSQL">

```sql
-- Adding created_at and updated_at columns to the users table
ALTER TABLE users
ADD COLUMN created_at TIMESTAMP DEFAULT NOW(),
ADD COLUMN updated_at TIMESTAMP DEFAULT NOW();

-- Creating a trigger function to update the updated_at column
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Creating a trigger that calls the trigger function on row updates
CREATE TRIGGER set_timestamp
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Creating an index for the created_at and updated_at columns
CREATE INDEX idx_users_created_at ON users (created_at);
CREATE INDEX idx_users_updated_at ON users (updated_at);
```
  </Accordion>

  <Accordion title="SQLite">
```sql
-- Adding created_at and updated_at columns to the users table
ALTER TABLE users
ADD COLUMN created_at INTEGER DEFAULT (strftime('%s', 'now')),
ADD COLUMN updated_at INTEGER DEFAULT (strftime('%s', 'now'));

-- Creating a trigger to update the updated_at column
CREATE TRIGGER set_timestamp
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
  UPDATE users SET updated_at = strftime('%s', 'now') WHERE id = OLD.id;
END;

-- Creating an index for the created_at and updated_at columns
CREATE INDEX idx_users_created_at ON users (created_at);
CREATE INDEX idx_users_updated_at ON users (updated_at);
```
  </Accordion>

  <Accordion title="Prisma">
  ```typescript
// Add created_at and updated_at fields in your Prisma schema
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```
  </Accordion>

  <Accordion title="Drizzle">

  ### Drizzle


Currently Drizzle doesn't support triggers or functions. 
**MySQL** is the only database where Drizzle allows you set the update functionality on.
For all other databases for Drizzle, you'll have to add the triggers directly in the migration scripts.

#### Drizzle + MySQL

```typescript
import { mysqlTable, serial, varchar, datetime } from 'drizzle-orm/mysql-core';
import { createTable } from 'drizzle-orm';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 256 }).notNull(),
  createdAt: datetime('created_at').defaultNow().notNull(),
  updatedAt: datetime('updated_at').defaultNow().notNull().onUpdateNow(),
});
```

#### Drizzle + PostgreSQL
```typescript
import { pgTable, serial, varchar, timestamp } from 'drizzle-orm/pg-core';
import { createTable } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 256 }).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});
```

Since you cannot create postgres triggers/functions in drizzle, you'll have to add the updated_at trigger in the migration script:

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

#### Drizzle + SQLite

```typescript
import { sqliteTable, integer, text } from 'drizzle-orm/sqlite-core';
import { createTable } from 'drizzle-orm';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey().autoincrement(),
  email: text('email').notNull(),
  createdAt: integer('created_at').default(Math.floor(Date.now() / 1000)).notNull(),
  updatedAt: integer('updated_at').default(Math.floor(Date.now() / 1000)).notNull(),
});
```

Since you cannot create SQLite triggers in drizzle, you'll have to add the updated_at trigger in the migration script:

```sql
CREATE TRIGGER set_timestamp
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
  UPDATE users SET updated_at = strftime('%s', 'now') WHERE id = OLD.id;
END;
```

  @TODO, Drizzle has index support, I should add that, but i am tired.



  </Accordion>
</AccordionGroup> 



## Creating Your Pollers

You will need **one** `Created Users Poller` to track when users are created.

And **one `Updated Users Poller` for each** table that has user data.

So if you have a `users` table and a `user_first_names` table. You'll need **one** poller to track user creations.
Then you need to make one poller to track updates in the `users` table, and one poller to track updates in the `user_first_names` table.

### Creating your Created Users Poller

To Create a Poller navigate to the Clerk Dashboard -> Pollers -> New Poller

<img height="200" src="/images/poller-create.png" />

Then select the `Create Users Poller` option.

You'll now need to fill in the function:

<img height="200" src="/images/pollNewlyCreatedUsers.png" />

<AccordionGroup>
  <Accordion title="Example">
```typescript
type CreatedUserCursor = {
  created_at: number;
  primary_key: any;
};

async function getNewlyCreatedUsers(
  cursor: CreatedUserCursor | null
): Promise<{
  users: CreateUserParams[];
  newCursor: CreatedUserCursor | null;
}> {
  const defaultCursor: CreatedUserCursor = { created_at: 0, primary_key: "" };
  const effectiveCursor = cursor || defaultCursor;

  const query = `
    SELECT * FROM users
    WHERE created_at > ?
    OR (created_at = ? AND external_id > ?)
    ORDER BY created_at ASC, external_id ASC
    LIMIT ?
  `;

  const result = await db.execute({
    sql: query,
    args: [effectiveCursor.created_at, effectiveCursor.created_at, effectiveCursor.primary_key, 10],
  });

  const users = result.rows.map((row) => ({
    externalId: row.external_id as string,
    emailAddress: [row.email as string],
    username: row.username as string,
    firstName: row.first_name as string,
    lastName: row.last_name as string,
    password: row.password as string,
  }));

  let newCursor: CreatedUserCursor | null;
  if (users.length > 0) {
    newCursor = {
      created_at: result.rows[result.rows.length - 1].created_at as number,
      primary_key: result.rows[result.rows.length - 1].external_id as string,
    };
  } else {
    newCursor = cursor;
  }

  return { users, newCursor };
}
```


  </Accordion>
</AccordionGroup>


<Tip>
  Since you could have multiple users with the same created_at timestamp, you need to include another column in the pagination logic, in this example we use the ID.
</Tip>

### Creating your Updated Users Poller(s)

To Create a Poller navigate to the Clerk Dashboard -> Pollers -> New Poller

<img height="200" src="/images/poller-create.png" />

Then select the `Updated Users Poller` option.

You'll now need to fill in the function:

<img height="200" src="/images/pollUpdatedUsers.png" />



<AccordionGroup>
  <Accordion title="Example">

```typescript
type UpdatedUserCursor = {
  updated_at: number;
  primary_key: any;
};

async function getUpdatedUsers(
  cursor: UpdatedUserCursor | null
): Promise<{
  users: CreateUserParams[];
  newCursor: UpdatedUserCursor | null;
}> {
  const defaultCursor: UpdatedUserCursor = { updated_at: 0, primary_key: "" };
  const effectiveCursor = cursor || defaultCursor;

  const query = `
    SELECT * FROM users
    WHERE updated_at > ?
    OR (updated_at = ? AND external_id > ?)
    ORDER BY updated_at ASC, external_id ASC
    LIMIT ?
  `;

  const result = await db.execute({
    sql: query,
    args: [effectiveCursor.updated_at, effectiveCursor.updated_at, effectiveCursor.primary_key, 10],
  });

  const users = result.rows.map((row) => ({
    externalId: row.external_id as string,
    emailAddress: [row.email as string],
    username: row.username as string,
    firstName: row.first_name as string,
    lastName: row.last_name as string,
    password: row.password as string,
  }));

  let newCursor: UpdatedUserCursor | null;
  if (users.length > 0) {
    newCursor = {
      updated_at: result.rows[result.rows.length - 1].updated_at as number,
      primary_key: result.rows[result.rows.length - 1].external_id as string,
    };
  } else {
    newCursor = cursor;
  }

  return { users, newCursor };
}
```

  </Accordion>
</AccordionGroup>


<Tip>
  Since you could have multiple users with the same created_at timestamp, you need to include another column in the pagination logic, in this example we use the ID.
</Tip>

